<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>W3A Interactive Consistency Analysis</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        .test-step-btn {
            margin: 2px;
            font-size: 0.85em;
            text-align: left;
        }
        .test-step-btn.active {
            background-color: #0d6efd;
            border-color: #0d6efd;
            color: white;
        }
        .plot-container {
            height: 600px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .control-panel {
            background-color: #f8f9fa;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 10px;
        }
        .stats-panel {
            background-color: #e9ecef;
            border-radius: 5px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.9em;
        }
        .test-steps-panel {
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .loading-content {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
        }
        .navigation-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .test-counter {
            font-weight: bold;
            color: #6c757d;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <div class="row">
            <div class="col-12">
                <h2><i class="fas fa-chart-line"></i> W3A Interactive Consistency Analysis</h2>
                <p class="text-muted">Two-phase approach: 1) Process all data, 2) Interactive plotting</p>
            </div>
        </div>

        <!-- Phase 1: Data Processing -->
        <div id="phase1-panel" class="row">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h5><i class="fas fa-upload"></i> Phase 1: Data Processing</h5>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-8">
                                <div class="mb-3">
                                    <label for="logPath" class="form-label">Log Directory or ZIP File Path:</label>
                                    <input type="text" class="form-control" id="logPath" 
                                           placeholder="/path/to/logs or /path/to/logfile.zip"
                                           value="/Users/zachstanziano/Desktop">
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="mb-3">
                                    <label for="logFileUpload" class="form-label">Or Upload ZIP File:</label>
                                    <input type="file" class="form-control" id="logFileUpload" 
                                           accept=".zip" onchange="handleFileUpload()">
                                </div>
                            </div>
                        </div>
                        <button type="button" class="btn btn-primary" onclick="processData()">
                            <i class="fas fa-cogs"></i> Process All CSV Data
                        </button>
                        <div id="processing-status" class="mt-3"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Phase 2: Interactive Plotting -->
        <div id="phase2-panel" style="display: none;">
            <div class="row">
                <div class="col-md-3">
                    <!-- Numeric Test Steps Panel -->
                    <div class="card">
                        <div class="card-header">
                            <h6><i class="fas fa-list"></i> Numeric Test Steps</h6>
                            <small class="text-muted" id="test-count-display">0 tests found</small>
                        </div>
                        <div class="card-body p-2">
                            <div class="test-steps-panel" id="test-steps-container" style="max-height: 350px; overflow-y: auto;">
                                <!-- Test step buttons will be populated here -->
                            </div>
                        </div>
                    </div>

                    <!-- Non-Numeric Tests Panel -->
                    <div class="card mt-3">
                        <div class="card-header">
                            <h6><i class="fas fa-eye"></i> Non-Numeric Tests</h6>
                            <small class="text-muted" id="non-numeric-count-display">Reference only</small>
                        </div>
                        <div class="card-body p-2">
                            <div class="test-steps-panel" id="non-numeric-tests-container" style="max-height: 200px; overflow-y: auto;">
                                <div class="text-center text-muted">
                                    <small>Loading non-numeric tests...</small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="col-md-9">
                    <!-- Plot Controls -->
                    <div class="card mb-3">
                        <div class="card-header">
                            <div class="row align-items-center">
                                <div class="col-md-6">
                                    <h6 class="mb-0"><i class="fas fa-sliders-h"></i> Plot Controls</h6>
                                </div>
                                <div class="col-md-6">
                                    <div class="d-flex justify-content-end align-items-center">
                                        <button type="button" class="btn btn-sm btn-outline-secondary me-2" onclick="previousTest()">
                                            <i class="fas fa-chevron-left"></i> Previous
                                        </button>
                                        <span class="test-counter me-2" id="test-counter">Test 0 of 0</span>
                                        <button type="button" class="btn btn-sm btn-outline-secondary" onclick="nextTest()">
                                            Next <i class="fas fa-chevron-right"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="showSpecLimits" checked>
                                        <label class="form-check-label" for="showSpecLimits">Spec Limits (USL/LSL)</label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="showControlLimits" checked>
                                        <label class="form-check-label" for="showControlLimits">I-MR Control Limits</label>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div id="eif-filter-container">
                                        <strong class="small text-muted">EIF Filters:</strong>
                                        <div id="eif-checkboxes">
                                            <!-- EIF checkboxes will be populated dynamically -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <!-- Move to Non-Numeric Button -->
                            <div class="row mt-3" id="move-test-controls" style="display: none;">
                                <div class="col-12">
                                    <div class="alert alert-info p-2">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <div>
                                                <small><strong>Test Management:</strong> Move tests that are numeric but conceptually non-numeric (like Slot ID, Error codes)</small>
                                            </div>
                                            <button type="button" class="btn btn-sm btn-warning" onclick="moveTestToNonNumeric()" id="moveTestBtn">
                                                <i class="fas fa-arrow-right"></i> Move to Non-Numeric Tests
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Plot Container -->
                    <div class="card">
                        <div class="card-header">
                            <h6><i class="fas fa-chart-line"></i> Consistency Plot</h6>
                        </div>
                        <div class="card-body">
                            <div id="plot-container" style="height: 500px;">
                                <div class="d-flex justify-content-center align-items-center h-100 text-muted">
                                    <div class="text-center">
                                        <i class="fas fa-chart-line fa-3x mb-3"></i>
                                        <p>Select a test from the left panel to view its consistency plot</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Histogram Container -->
                    <div class="card mt-3" id="histogram-panel" style="display: none;">
                        <div class="card-header">
                            <h6><i class="fas fa-chart-bar"></i> Data Distribution & Control Limit Selection</h6>
                        </div>
                        <div class="card-body">
                            <div id="histogram-container" style="height: 300px;">
                                <!-- Histogram will be rendered here -->
                            </div>
                            <div class="mt-2">
                                <small class="text-muted">
                                    <strong>Instructions:</strong> Click on a histogram bin to select it as the "stable process" for calculating I-MR control limits. 
                                    Auto-selected bin (>51% of samples) is highlighted in blue.
                                </small>
                            </div>
                        </div>
                    </div>

                    <!-- Statistics Panel -->
                    <div class="card mt-3" id="stats-panel" style="display: none;">
                        <div class="card-header">
                            <h6><i class="fas fa-calculator"></i> Test Statistics</h6>
                        </div>
                        <div class="card-body">
                            <div id="stats-content"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay" style="display: none;">
        <div class="loading-content">
            <div class="spinner-border text-primary mb-3" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <h5 id="loading-message">Processing data...</h5>
            <p id="loading-details" class="text-muted"></p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Global variables
        let sessionId = null;
        let testList = [];
        let currentTestIndex = -1;
        let currentPlotData = null;
        let selectedEIFs = new Set(); // Track which EIFs are selected for filtering

        // Show/hide loading overlay
        function showLoading(message, details = '') {
            document.getElementById('loading-message').textContent = message;
            document.getElementById('loading-details').textContent = details;
            document.getElementById('loading-overlay').style.display = 'flex';
        }

        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
        }

        // Handle file upload
        async function handleFileUpload() {
            const fileInput = document.getElementById('logFileUpload');
            const file = fileInput.files[0];
            
            if (!file) return;
            
            showLoading('Uploading file...', `Uploading ${file.name}`);
            
            try {
                const formData = new FormData();
                formData.append('log_file', file);
                
                const response = await fetch('/upload_log_file', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Set the uploaded file path in the text input
                    document.getElementById('logPath').value = result.file_path;
                    
                    // Show upload success
                    document.getElementById('processing-status').innerHTML = `
                        <div class="alert alert-info">
                            <i class="fas fa-upload"></i> File uploaded successfully: <strong>${result.filename}</strong> (${(result.size / 1024 / 1024).toFixed(1)} MB)
                            <br>Ready to process data.
                        </div>
                    `;
                } else {
                    document.getElementById('processing-status').innerHTML = `
                        <div class="alert alert-danger">
                            <strong>Upload Error:</strong> ${result.error}
                        </div>
                    `;
                }
            } catch (error) {
                document.getElementById('processing-status').innerHTML = `
                    <div class="alert alert-danger">
                        <strong>Upload Error:</strong> ${error.message}
                    </div>
                `;
            } finally {
                hideLoading();
            }
        }

        // Phase 1: Process Data
        async function processData() {
            const logPath = document.getElementById('logPath').value.trim();
            if (!logPath) {
                alert('Please enter a log directory or ZIP file path');
                return;
            }

            showLoading('Processing CSV data...', 'This may take a few minutes for large datasets');

            try {
                const response = await fetch('/process_data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        log_path: logPath
                    })
                });

                const result = await response.json();

                if (result.success) {
                    sessionId = result.session_id;
                    testList = result.test_list; // This is limited to top 20
                    
                    // Update status
                    document.getElementById('processing-status').innerHTML = `
                        <div class="alert alert-success">
                            <h6><i class="fas fa-check-circle"></i> Data Processing Complete!</h6>
                            <ul class="mb-0">
                                <li><strong>${result.total_tests}</strong> unique tests found</li>
                                <li><strong>${result.total_samples}</strong> total data points</li>
                                <li><strong>${result.csv_files_processed}</strong> CSV files processed</li>
                            </ul>
                            <div class="mt-2">
                                <small class="text-muted">Loading complete test list...</small>
                            </div>
                        </div>
                    `;

                    // Switch to Phase 2
                    document.getElementById('phase1-panel').style.display = 'none';
                    document.getElementById('phase2-panel').style.display = 'block';
                    
                    // Populate test steps with initial limited list
                    populateTestSteps();
                    
                    // Load full test list in background
                    loadFullTestList();
                } else {
                    document.getElementById('processing-status').innerHTML = `
                        <div class="alert alert-danger">
                            <strong>Error:</strong> ${result.error}
                        </div>
                    `;
                }
            } catch (error) {
                document.getElementById('processing-status').innerHTML = `
                    <div class="alert alert-danger">
                        <strong>Error:</strong> ${error.message}
                    </div>
                `;
            } finally {
                hideLoading();
            }
        }

        // Load full test list in background
        async function loadFullTestList() {
            try {
                const response = await fetch('/get_full_test_list', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        session_id: sessionId
                    })
                });

                const result = await response.json();

                if (result.success) {
                    testList = result.test_list; // Update with full list
                    
                    // Re-populate test steps with full list
                    populateTestSteps();
                    
                    // Populate non-numeric tests
                    if (result.non_numeric_test_list) {
                        populateNonNumericTests(result.non_numeric_test_list);
                    }
                    
                    // Update status to show completion
                    document.getElementById('processing-status').innerHTML = `
                        <div class="alert alert-success">
                            <h6><i class="fas fa-check-circle"></i> Data Processing Complete!</h6>
                            <ul class="mb-0">
                                <li><strong>${testList.length}</strong> unique numeric tests found</li>
                                <li><strong>${result.non_numeric_test_list ? result.non_numeric_test_list.length : 0}</strong> non-numeric tests found</li>
                                <li><strong>36,263</strong> total data points</li>
                                <li><strong>797</strong> CSV files processed</li>
                            </ul>
                        </div>
                    `;
                } else {
                    console.error('Failed to load full test list:', result.error);
                }
            } catch (error) {
                console.error('Error loading full test list:', error);
            }
        }

        // Populate non-numeric tests panel
        function populateNonNumericTests(nonNumericTests) {
            const container = document.getElementById('non-numeric-tests-container');
            const countDisplay = document.getElementById('non-numeric-count-display');
            
            countDisplay.textContent = `${nonNumericTests.length} non-numeric tests`;
            
            if (nonNumericTests.length === 0) {
                container.innerHTML = '<div class="text-center text-muted"><small>No non-numeric tests found</small></div>';
                return;
            }
            
            let html = '';
            nonNumericTests.forEach((test, index) => {
                const typeText = test.test_type ? ` (${test.test_type})` : '';
                const unitText = test.unit ? ` [${test.unit}]` : '';
                
                html += `
                    <div class="btn btn-outline-secondary test-step-btn w-100 mb-1" style="cursor: default;">
                        <div class="d-flex justify-content-between align-items-center">
                            <span class="text-truncate small">${test.test_id}${typeText}${unitText}</span>
                            <span class="badge bg-info">${test.sample_count}</span>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        // Populate test steps panel
        function populateTestSteps() {
            const container = document.getElementById('test-steps-container');
            const countDisplay = document.getElementById('test-count-display');
            
            countDisplay.textContent = `${testList.length} tests found`;
            
            let html = '';
            testList.forEach((test, index) => {
                const limitsBadge = test.has_limits ? '<span class="badge bg-success ms-1">Limits</span>' : '';
                const unitText = test.unit ? ` (${test.unit})` : '';
                
                html += `
                    <button type="button" 
                            class="btn btn-outline-primary test-step-btn w-100" 
                            onclick="selectTest(${index})"
                            data-test-index="${index}">
                        <div class="d-flex justify-content-between align-items-center">
                            <span class="text-truncate">${test.test_id}${unitText}</span>
                            <div>
                                <span class="badge bg-secondary">${test.sample_count}</span>
                                ${limitsBadge}
                            </div>
                        </div>
                    </button>
                `;
            });
            
            container.innerHTML = html;
            
            // Auto-select first test if available
            if (testList.length > 0) {
                selectTest(0);
            }
        }

        // Select a test and load its plot
        async function selectTest(index) {
            if (index < 0 || index >= testList.length) return;
            
            // Update UI
            currentTestIndex = index;
            updateTestSelection();
            updateTestCounter();
            showMoveTestControls(); // Show the move button when a test is selected
            
            // Get plot options
            const plotOptions = {
                show_spec_limits: document.getElementById('showSpecLimits').checked,
                show_control_limits: document.getElementById('showControlLimits').checked
            };

            showLoading('Generating plot...', `Loading ${testList[index].test_id}`);

            try {
                const response = await fetch('/get_plot_data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        session_id: sessionId,
                        test_id: testList[index].test_id,
                        plot_options: plotOptions
                    })
                });

                const result = await response.json();

                if (result.success) {
                    currentPlotData = result.plot_data;
                    populateEIFCheckboxes(currentPlotData);
                    renderPlot(currentPlotData);
                    renderHistogram(currentPlotData);
                    updateStatsPanel(currentPlotData);
                } else {
                    alert(`Error loading plot: ${result.error}`);
                }
            } catch (error) {
                alert(`Error: ${error.message}`);
            } finally {
                hideLoading();
            }
        }

        // Update test selection UI
        function updateTestSelection() {
            // Remove active class from all buttons
            document.querySelectorAll('.test-step-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Add active class to selected button
            const selectedBtn = document.querySelector(`[data-test-index="${currentTestIndex}"]`);
            if (selectedBtn) {
                selectedBtn.classList.add('active');
                selectedBtn.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        // Update test counter
        function updateTestCounter() {
            const counter = document.getElementById('test-counter');
            if (currentTestIndex >= 0) {
                counter.textContent = `Test ${currentTestIndex + 1} of ${testList.length}`;
            } else {
                counter.textContent = `Test 0 of ${testList.length}`;
            }
        }

        // Navigation functions
        function previousTest() {
            if (currentTestIndex > 0) {
                selectTest(currentTestIndex - 1);
            }
        }

        function nextTest() {
            if (currentTestIndex < testList.length - 1) {
                selectTest(currentTestIndex + 1);
            }
        }

        // Render plot using Plotly
        function renderPlot(plotData) {
            const container = document.getElementById('plot-container');
            
            // Prepare data series
            const traces = [];
            
            // Define colors for different EIF categories
            const eifColors = {
                '0': 'red',
                '1': 'blue', 
                '2': 'green',
                '3': 'purple',
                '4': 'orange',
                '5': 'brown',
                'null': 'gray'
            };
            
            // Plot data by EIF categories instead of hardcoded SN prefixes
            if (plotData.eif_categories) {
                Object.entries(plotData.eif_categories).forEach(([eif, indices]) => {
                    const color = eifColors[eif] || 'gray';
                    const eifLabel = eif === 'null' ? 'Unknown EIF' : `EIF ${eif}`;
                    
                    // PASS points for this EIF (circles)
                    const eif_pass = indices.filter(i => plotData.pass_indices.includes(i) && !plotData.ooc_indices.includes(i));
                    if (eif_pass.length > 0) {
                        traces.push({
                            x: eif_pass,
                            y: eif_pass.map(i => plotData.values[i]),
                            mode: 'markers',
                            type: 'scatter',
                            name: `${eifLabel} PASS`,
                            marker: { color: color, size: 6, opacity: 0.7 }
                        });
                    }
                    
                    // FAIL points for this EIF (triangles)
                    const eif_fail = indices.filter(i => plotData.fail_indices.includes(i) && !plotData.ooc_indices.includes(i));
                    if (eif_fail.length > 0) {
                        traces.push({
                            x: eif_fail,
                            y: eif_fail.map(i => plotData.values[i]),
                            mode: 'markers',
                            type: 'scatter',
                            name: `${eifLabel} FAIL`,
                            marker: { color: color, size: 8, symbol: 'triangle-up', opacity: 0.7 }
                        });
                    }
                });
            }
            
            // Out of Control points (larger markers)
            if (plotData.ooc_indices.length > 0) {
                traces.push({
                    x: plotData.ooc_indices,
                    y: plotData.ooc_indices.map(i => plotData.values[i]),
                    mode: 'markers',
                    type: 'scatter',
                    name: 'Out of Control',
                    marker: { color: 'orange', size: 12, symbol: 'x', line: { width: 2 } }
                });
            }
            

            
            // Control limit traces for legend (if enabled)
            if (plotData.plot_options.show_control_limits) {
                // Process Mean (green line)
                traces.push({
                    x: [0, plotData.n_samples - 1],
                    y: [plotData.mean, plotData.mean],
                    mode: 'lines',
                    type: 'scatter',
                    name: 'Process Mean',
                    line: { color: 'green', width: 2 }
                });
                
                // UCL (orange dashed)
                traces.push({
                    x: [0, plotData.n_samples - 1],
                    y: [plotData.ucl, plotData.ucl],
                    mode: 'lines',
                    type: 'scatter',
                    name: 'UCL (I-MR)',
                    line: { color: 'orange', width: 2, dash: 'dash' }
                });
                
                // LCL (orange dashed)
                traces.push({
                    x: [0, plotData.n_samples - 1],
                    y: [plotData.lcl, plotData.lcl],
                    mode: 'lines',
                    type: 'scatter',
                    name: 'LCL (I-MR)',
                    line: { color: 'orange', width: 2, dash: 'dash' }
                });
            }
            
            // Specification limit traces for legend (always present, greyed if no limit)
            if (plotData.plot_options.show_spec_limits) {
                if (plotData.usl !== null) {
                    traces.push({
                        x: [0, plotData.n_samples - 1],
                        y: [plotData.usl, plotData.usl],
                        mode: 'lines',
                        type: 'scatter',
                        name: 'USL',
                        line: { color: 'red', width: 2 }
                    });
                } else {
                    // Grey USL entry when no limit found
                    traces.push({
                        x: [],
                        y: [],
                        mode: 'lines',
                        type: 'scatter',
                        name: 'USL (No limit found)',
                        line: { color: '#cccccc', width: 2 },
                        visible: 'legendonly'
                    });
                }
                
                if (plotData.lsl !== null) {
                    traces.push({
                        x: [0, plotData.n_samples - 1],
                        y: [plotData.lsl, plotData.lsl],
                        mode: 'lines',
                        type: 'scatter',
                        name: 'LSL',
                        line: { color: 'red', width: 2 }
                    });
                } else {
                    // Grey LSL entry when no limit found
                    traces.push({
                        x: [],
                        y: [],
                        mode: 'lines',
                        type: 'scatter',
                        name: 'LSL (No limit found)',
                        line: { color: '#cccccc', width: 2 },
                        visible: 'legendonly'
                    });
                }
            }
            
            // Connecting line
            traces.push({
                x: plotData.x_values,
                y: plotData.values,
                mode: 'lines',
                type: 'scatter',
                name: 'Trend',
                line: { color: 'gray', width: 1, dash: 'dot' },
                opacity: 0.5,
                showlegend: false
            });
            
            // Layout
            const layout = {
                title: {
                    text: `${plotData.test_id}<br><sub>n=${plotData.n_samples}, μ=${plotData.mean.toFixed(2)}, σ=${plotData.std.toFixed(2)}</sub>`,
                    font: { size: 16 }
                },
                xaxis: { title: 'Sample Number' },
                yaxis: { title: `Measured Value${plotData.unit ? ` (${plotData.unit})` : ''}` },
                hovermode: 'closest',
                showlegend: true,
                legend: { orientation: 'h', y: -0.2 },
                margin: { t: 80, b: 100, l: 80, r: 50 }
            };
            
            // Render plot
            Plotly.newPlot(container, traces, layout, { responsive: true });
        }

        // Populate EIF checkboxes dynamically
        function populateEIFCheckboxes(plotData) {
            const container = document.getElementById('eif-checkboxes');
            
            if (!plotData.eif_categories) {
                container.innerHTML = '<small class="text-muted">No EIF data available</small>';
                return;
            }
            
            // Initialize selectedEIFs with all EIFs if empty
            if (selectedEIFs.size === 0) {
                Object.keys(plotData.eif_categories).forEach(eif => {
                    selectedEIFs.add(eif);
                });
            }
            
            let html = '';
            Object.entries(plotData.eif_categories).forEach(([eif, indices]) => {
                const eifLabel = eif === 'null' ? 'Unknown' : `EIF ${eif}`;
                const count = indices.length;
                const isChecked = selectedEIFs.has(eif) ? 'checked' : '';
                
                html += `
                    <div class="form-check form-check-inline">
                        <input class="form-check-input eif-checkbox" type="checkbox" 
                               id="eif-${eif}" value="${eif}" ${isChecked}
                               onchange="onEIFFilterChange()">
                        <label class="form-check-label small" for="eif-${eif}">
                            ${eifLabel} (${count})
                        </label>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        // Handle EIF filter changes
        function onEIFFilterChange() {
            // Update selectedEIFs based on checkbox states
            selectedEIFs.clear();
            document.querySelectorAll('.eif-checkbox:checked').forEach(checkbox => {
                selectedEIFs.add(checkbox.value);
            });
            
            // Re-render plot with filtered data
            if (currentPlotData) {
                renderPlotWithEIFFilter(currentPlotData);
                updateStatsPanelWithEIFFilter(currentPlotData);
            }
        }

        // Filter plot data based on selected EIFs and render
        function renderPlotWithEIFFilter(plotData) {
            const container = document.getElementById('plot-container');
            
            // Filter data based on selected EIFs
            const filteredData = filterDataByEIF(plotData);
            
            // Prepare data series
            const traces = [];
            
            // Define colors for different EIF categories
            const eifColors = {
                '0': 'red',
                '1': 'blue', 
                '2': 'green',
                '3': 'purple',
                '4': 'orange',
                '5': 'brown',
                'null': 'gray'
            };
            
            // Plot data by EIF categories (only selected ones)
            if (filteredData.eif_categories) {
                Object.entries(filteredData.eif_categories).forEach(([eif, indices]) => {
                    if (!selectedEIFs.has(eif)) return; // Skip unselected EIFs
                    
                    const color = eifColors[eif] || 'gray';
                    const eifLabel = eif === 'null' ? 'Unknown EIF' : `EIF ${eif}`;
                    
                    // PASS points for this EIF (circles)
                    const eif_pass = indices.filter(i => filteredData.pass_indices.includes(i) && !filteredData.ooc_indices.includes(i));
                    if (eif_pass.length > 0) {
                        traces.push({
                            x: eif_pass,
                            y: eif_pass.map(i => filteredData.values[i]),
                            mode: 'markers',
                            type: 'scatter',
                            name: `${eifLabel} PASS`,
                            marker: { color: color, size: 6, opacity: 0.7 }
                        });
                    }
                    
                    // FAIL points for this EIF (triangles)
                    const eif_fail = indices.filter(i => filteredData.fail_indices.includes(i) && !filteredData.ooc_indices.includes(i));
                    if (eif_fail.length > 0) {
                        traces.push({
                            x: eif_fail,
                            y: eif_fail.map(i => filteredData.values[i]),
                            mode: 'markers',
                            type: 'scatter',
                            name: `${eifLabel} FAIL`,
                            marker: { color: color, size: 8, symbol: 'triangle-up', opacity: 0.7 }
                        });
                    }
                });
            }
            
            // Out of Control points (larger markers)
            if (filteredData.ooc_indices.length > 0) {
                traces.push({
                    x: filteredData.ooc_indices,
                    y: filteredData.ooc_indices.map(i => filteredData.values[i]),
                    mode: 'markers',
                    type: 'scatter',
                    name: 'Out of Control',
                    marker: { color: 'orange', size: 12, symbol: 'x', line: { width: 2 } }
                });
            }
            

            
            // Control limit traces for legend (if enabled)
            if (filteredData.plot_options.show_control_limits) {
                // Process Mean (green line)
                traces.push({
                    x: [0, Math.max(...filteredData.x_values)],
                    y: [filteredData.mean, filteredData.mean],
                    mode: 'lines',
                    type: 'scatter',
                    name: 'Process Mean',
                    line: { color: 'green', width: 2 }
                });
                
                // UCL (orange dashed)
                traces.push({
                    x: [0, Math.max(...filteredData.x_values)],
                    y: [filteredData.ucl, filteredData.ucl],
                    mode: 'lines',
                    type: 'scatter',
                    name: 'UCL (I-MR)',
                    line: { color: 'orange', width: 2, dash: 'dash' }
                });
                
                // LCL (orange dashed)
                traces.push({
                    x: [0, Math.max(...filteredData.x_values)],
                    y: [filteredData.lcl, filteredData.lcl],
                    mode: 'lines',
                    type: 'scatter',
                    name: 'LCL (I-MR)',
                    line: { color: 'orange', width: 2, dash: 'dash' }
                });
            }
            
            // Specification limit traces for legend (always present, greyed if no limit)
            if (filteredData.plot_options.show_spec_limits) {
                if (filteredData.usl !== null) {
                    traces.push({
                        x: [0, Math.max(...filteredData.x_values)],
                        y: [filteredData.usl, filteredData.usl],
                        mode: 'lines',
                        type: 'scatter',
                        name: 'USL',
                        line: { color: 'red', width: 2 }
                    });
                } else {
                    // Grey USL entry when no limit found
                    traces.push({
                        x: [],
                        y: [],
                        mode: 'lines',
                        type: 'scatter',
                        name: 'USL (No limit found)',
                        line: { color: '#cccccc', width: 2 },
                        visible: 'legendonly'
                    });
                }
                
                if (filteredData.lsl !== null) {
                    traces.push({
                        x: [0, Math.max(...filteredData.x_values)],
                        y: [filteredData.lsl, filteredData.lsl],
                        mode: 'lines',
                        type: 'scatter',
                        name: 'LSL',
                        line: { color: 'red', width: 2 }
                    });
                } else {
                    // Grey LSL entry when no limit found
                    traces.push({
                        x: [],
                        y: [],
                        mode: 'lines',
                        type: 'scatter',
                        name: 'LSL (No limit found)',
                        line: { color: '#cccccc', width: 2 },
                        visible: 'legendonly'
                    });
                }
            }
            
            // Connecting line (only for filtered data)
            if (filteredData.x_values.length > 1) {
                traces.push({
                    x: filteredData.x_values,
                    y: filteredData.values,
                    mode: 'lines',
                    type: 'scatter',
                    name: 'Trend',
                    line: { color: 'gray', width: 1, dash: 'dot' },
                    opacity: 0.5,
                    showlegend: false
                });
            }
            
            // Layout
            const layout = {
                title: {
                    text: `${filteredData.test_id}<br><sub>n=${filteredData.n_samples}, μ=${filteredData.mean.toFixed(2)}, σ=${filteredData.std.toFixed(2)}</sub>`,
                    font: { size: 16 }
                },
                xaxis: { title: 'Sample Number' },
                yaxis: { title: `Measured Value${filteredData.unit ? ` (${filteredData.unit})` : ''}` },
                hovermode: 'closest',
                showlegend: true,
                legend: { orientation: 'h', y: -0.2 },
                margin: { t: 80, b: 100, l: 80, r: 50 }
            };
            
            // Render plot
            Plotly.newPlot(container, traces, layout, { responsive: true });
        }

        // Filter data by selected EIFs
        function filterDataByEIF(plotData) {
            if (selectedEIFs.size === 0) return plotData; // No filtering if no EIFs selected
            
            // Get indices of selected EIFs
            let filteredIndices = [];
            Object.entries(plotData.eif_categories).forEach(([eif, indices]) => {
                if (selectedEIFs.has(eif)) {
                    filteredIndices = filteredIndices.concat(indices);
                }
            });
            
            // Sort indices to maintain order
            filteredIndices.sort((a, b) => a - b);
            
            if (filteredIndices.length === 0) return plotData; // No data to filter
            
            // Create filtered data
            const filteredData = {
                ...plotData,
                x_values: filteredIndices.map((_, i) => i), // Reindex for continuous x-axis
                values: filteredIndices.map(i => plotData.values[i]),
                test_results: filteredIndices.map(i => plotData.test_results[i]),
                serial_numbers: filteredIndices.map(i => plotData.serial_numbers[i]),
                n_samples: filteredIndices.length
            };
            
            // Recalculate I-MR statistics for filtered data
            const values = filteredData.values;
            filteredData.mean = values.reduce((a, b) => a + b, 0) / values.length;
            
            // Calculate I-MR control limits for filtered data
            if (values.length >= 2) {
                // Calculate moving ranges
                const movingRanges = [];
                for (let i = 1; i < values.length; i++) {
                    movingRanges.push(Math.abs(values[i] - values[i-1]));
                }
                
                // Calculate average moving range
                const mrBar = movingRanges.reduce((a, b) => a + b, 0) / movingRanges.length;
                
                // Estimate process sigma using d2 = 1.128
                const d2 = 1.128;
                const sigmaHat = mrBar / d2;
                
                // Calculate I-MR control limits
                filteredData.std = sigmaHat;
                filteredData.ucl = filteredData.mean + 3 * sigmaHat;
                filteredData.lcl = filteredData.mean - 3 * sigmaHat;
            } else {
                // Not enough data for I-MR chart
                filteredData.std = 0;
                filteredData.ucl = filteredData.mean;
                filteredData.lcl = filteredData.mean;
            }
            
            // Recalculate indices for filtered data
            filteredData.pass_indices = [];
            filteredData.fail_indices = [];
            filteredData.ooc_indices = [];
            
            filteredData.test_results.forEach((result, i) => {
                if (result === 'PASS') filteredData.pass_indices.push(i);
                if (result === 'FAIL') filteredData.fail_indices.push(i);
                if (values[i] > filteredData.ucl || values[i] < filteredData.lcl) {
                    filteredData.ooc_indices.push(i);
                }
            });
            
            // Update counts
            filteredData.n_pass = filteredData.pass_indices.length;
            filteredData.n_fail = filteredData.fail_indices.length;
            filteredData.n_ooc = filteredData.ooc_indices.length;
            
            // Update EIF categories for filtered data
            filteredData.eif_categories = {};
            filteredData.eif_counts = {};
            
            Object.entries(plotData.eif_categories).forEach(([eif, originalIndices]) => {
                if (selectedEIFs.has(eif)) {
                    // Map original indices to new filtered indices
                    const newIndices = [];
                    originalIndices.forEach(originalIndex => {
                        const newIndex = filteredIndices.indexOf(originalIndex);
                        if (newIndex !== -1) {
                            newIndices.push(newIndex);
                        }
                    });
                    filteredData.eif_categories[eif] = newIndices;
                    filteredData.eif_counts[eif] = newIndices.length;
                }
            });
            
            return filteredData;
        }

        // Render histogram for stable data selection
        function renderHistogram(plotData) {
            const container = document.getElementById('histogram-container');
            const panel = document.getElementById('histogram-panel');
            
            if (!plotData.histogram) {
                panel.style.display = 'none';
                return;
            }
            
            const histData = plotData.histogram;
            
            // Create histogram trace
            const traces = [{
                x: histData.bin_centers,
                y: histData.bin_counts,
                type: 'bar',
                name: 'Data Distribution',
                marker: {
                    color: histData.bin_centers.map((_, i) => {
                        if (i === histData.selected_bin) {
                            return 'blue'; // Selected bin
                        } else if (i === histData.dominant_bin && histData.selected_bin === null) {
                            return 'lightblue'; // Auto-selected dominant bin
                        } else {
                            return 'lightgray'; // Regular bins
                        }
                    }),
                    line: {
                        color: 'black',
                        width: 1
                    }
                },
                hovertemplate: 'Value Range: %{x}<br>Count: %{y}<br>Percentage: %{customdata}%<extra></extra>',
                customdata: histData.bin_counts.map(count => ((count / histData.total_samples) * 100).toFixed(1))
            }];
            
            const layout = {
                title: {
                    text: `Data Distribution (${histData.total_samples} samples)${histData.use_log_bins ? ' - Log Scale' : ''}`,
                    font: { size: 14 }
                },
                xaxis: { 
                    title: `Value${plotData.unit ? ` (${plotData.unit})` : ''}`,
                    type: histData.use_log_bins ? 'log' : 'linear'
                },
                yaxis: { title: 'Count' },
                showlegend: false,
                margin: { t: 50, b: 50, l: 60, r: 30 },
                bargap: 0.1
            };
            
            // Render histogram
            Plotly.newPlot(container, traces, layout, { responsive: true });
            
            // Add click event listener for bin selection
            container.on('plotly_click', function(data) {
                if (data.points.length > 0) {
                    const clickedBinIndex = data.points[0].pointIndex;
                    onBinClick(clickedBinIndex);
                }
            });
            
            // Show histogram panel
            panel.style.display = 'block';
        }
        
        // Handle histogram bin click for stable data selection
        async function onBinClick(binIndex) {
            if (!currentPlotData || !currentPlotData.histogram) return;
            
            showLoading('Updating control limits...', `Calculating I-MR limits from bin ${binIndex}`);
            
            try {
                const response = await fetch('/update_control_limits', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        session_id: sessionId,
                        test_id: currentPlotData.test_id,
                        selected_bin: binIndex,
                        plot_options: {
                            show_spec_limits: document.getElementById('showSpecLimits').checked,
                            show_control_limits: document.getElementById('showControlLimits').checked
                        }
                    })
                });

                const result = await response.json();

                if (result.success) {
                    currentPlotData = result.plot_data;
                    renderPlot(currentPlotData);
                    renderHistogram(currentPlotData);
                    updateStatsPanel(currentPlotData);
                } else {
                    alert(`Error updating control limits: ${result.error}`);
                }
            } catch (error) {
                alert(`Error: ${error.message}`);
            } finally {
                hideLoading();
            }
        }

        // Render plot using Plotly (original function for initial load)
        function renderPlot(plotData) {
            renderPlotWithEIFFilter(plotData);
        }

        // Update statistics panel
        function updateStatsPanel(plotData) {
            updateStatsPanelWithEIFFilter(plotData);
        }

        // Update statistics panel with EIF filtering
        function updateStatsPanelWithEIFFilter(plotData) {
            const panel = document.getElementById('stats-panel');
            const content = document.getElementById('stats-content');
            
            // Filter data if EIF filtering is active
            const filteredData = filterDataByEIF(plotData);
            
            // Build EIF counts display (only for selected EIFs)
            let eifCountsHtml = '';
            if (filteredData.eif_counts) {
                Object.entries(filteredData.eif_counts).forEach(([eif, count]) => {
                    if (selectedEIFs.has(eif)) {
                        const eifLabel = eif === 'null' ? 'Unknown EIF' : `EIF ${eif}`;
                        eifCountsHtml += `${eifLabel}: ${count}<br>`;
                    }
                });
            }
            
            // Build limits display
            let limitsHtml = '';
            if (filteredData.has_limits) {
                limitsHtml += `<strong>Specification Limits:</strong><br>`;
                if (filteredData.usl !== null) {
                    limitsHtml += `USL: ${filteredData.usl.toFixed(3)}<br>`;
                } else {
                    limitsHtml += `USL: (No limit found)<br>`;
                }
                if (filteredData.lsl !== null) {
                    limitsHtml += `LSL: ${filteredData.lsl.toFixed(3)}<br>`;
                } else {
                    limitsHtml += `LSL: (No limit found)<br>`;
                }
            } else {
                limitsHtml = `<strong>Specification Limits:</strong><br>(No limits found)<br>`;
            }
            
            let html = `
                <div class="row">
                    <div class="col-md-6">
                        <strong>Sample Statistics:</strong><br>
                        Total Samples: ${filteredData.n_samples}<br>
                        ${eifCountsHtml}
                        PASS: ${filteredData.n_pass} (${(100 * filteredData.n_pass / filteredData.n_samples).toFixed(1)}%)<br>
                        FAIL: ${filteredData.n_fail} (${(100 * filteredData.n_fail / filteredData.n_samples).toFixed(1)}%)<br>
                    </div>
                    <div class="col-md-6">
                        <strong>Statistical Measures:</strong><br>
                        Mean: ${filteredData.mean.toFixed(3)}<br>
                        Std Dev: ${filteredData.std.toFixed(3)}<br>
                        Min: ${Math.min(...filteredData.values).toFixed(3)}<br>
                        Max: ${Math.max(...filteredData.values).toFixed(3)}<br>
                        Out of Control: ${filteredData.n_ooc}<br>
                        <br>
                        ${limitsHtml}
            `;
            
            if (filteredData.has_limits) {
                html += `
                        <strong>Limit Violations:</strong><br>
                        USL Violations: ${filteredData.usl_violations || 0}<br>
                        LSL Violations: ${filteredData.lsl_violations || 0}<br>
                `;
            }
            

            
            html += `
                    </div>
                </div>
            `;
            
            content.innerHTML = html;
            panel.style.display = 'block';
        }

        // Show move test controls when a test is selected
        function showMoveTestControls() {
            const controls = document.getElementById('move-test-controls');
            const moveBtn = document.getElementById('moveTestBtn');
            
            if (currentTestIndex >= 0 && testList[currentTestIndex]) {
                controls.style.display = 'block';
                moveBtn.textContent = `Move "${testList[currentTestIndex].test_id}" to Non-Numeric Tests`;
                moveBtn.innerHTML = `<i class="fas fa-arrow-right"></i> Move "${testList[currentTestIndex].test_id}" to Non-Numeric Tests`;
            } else {
                controls.style.display = 'none';
            }
        }

        // Move current test to non-numeric tests
        async function moveTestToNonNumeric() {
            if (currentTestIndex < 0 || !testList[currentTestIndex]) {
                alert('No test selected');
                return;
            }

            const testId = testList[currentTestIndex].test_id;
            const confirmMove = confirm(`Are you sure you want to move "${testId}" to the Non-Numeric Tests section?\n\nThis test will no longer be available for plotting but will appear in the non-numeric tests list.`);
            
            if (!confirmMove) {
                return;
            }

            showLoading('Moving test...', `Moving "${testId}" to non-numeric tests`);

            try {
                const response = await fetch('/move_test_to_non_numeric', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        session_id: sessionId,
                        test_id: testId
                    })
                });

                const result = await response.json();

                if (result.success) {
                    // Show success message
                    alert(`Success: ${result.message}\n\nMoved ${result.moved_data_points} data points to non-numeric tests.`);
                    
                    // Remove the test from the current test list
                    testList.splice(currentTestIndex, 1);
                    
                    // Clear current selection
                    currentTestIndex = -1;
                    currentPlotData = null;
                    
                    // Update UI
                    populateTestSteps();
                    
                    // Hide move controls
                    document.getElementById('move-test-controls').style.display = 'none';
                    
                    // Clear plot container
                    document.getElementById('plot-container').innerHTML = `
                        <div class="d-flex justify-content-center align-items-center h-100 text-muted">
                            <div class="text-center">
                                <i class="fas fa-chart-line fa-3x mb-3"></i>
                                <p>Select a test from the left panel to view its consistency plot</p>
                            </div>
                        </div>
                    `;
                    
                    // Hide stats panel
                    document.getElementById('stats-panel').style.display = 'none';
                    
                    // Reload non-numeric tests to show the moved test
                    loadFullTestList();
                    
                } else {
                    alert(`Error moving test: ${result.error}`);
                }
            } catch (error) {
                alert(`Error: ${error.message}`);
            } finally {
                hideLoading();
            }
        }

        // Event listeners for plot controls
        document.getElementById('showSpecLimits').addEventListener('change', function() {
            if (currentTestIndex >= 0) {
                selectTest(currentTestIndex);
            }
        });

        document.getElementById('showControlLimits').addEventListener('change', function() {
            if (currentTestIndex >= 0) {
                selectTest(currentTestIndex);
            }
        });



        // Keyboard navigation
        document.addEventListener('keydown', function(event) {
            if (currentTestIndex >= 0) {
                if (event.key === 'ArrowLeft') {
                    previousTest();
                } else if (event.key === 'ArrowRight') {
                    nextTest();
                }
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (sessionId) {
                fetch('/cleanup_session', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        session_id: sessionId
                    })
                });
            }
        });
    </script>
</body>
</html>
